.. default-domain:: chpl

.. module:: UniqueMsg
   :synopsis: unique finding and counting algorithms

UniqueMsg
=========
**Usage**

.. code-block:: chapel

   use UniqueMsg;

unique finding and counting algorithms
these are all based on dense histograms and sparse histograms(assoc domains/arrays)

you could also use a sort if you got into a real bind with really
large dense ranges of values and large arrays...

*** need to factor in sparsity estimation somehow ***
for example if (a.max-a.min > a.size) means that a's are sparse



.. data:: var sBins = 2**10

.. data:: var mBins = 2**20

.. data:: var lBins = 2**26*numLocales

.. function:: proc +(x: atomicint, y: atomicint)

.. function:: proc +=(X: [?D] int, Y: [D] atomicint)

.. function:: proc uniqueGlobHist(a: [?aD] int, aMin: int, aMax: int)

   unique with global histogram 

.. function:: proc uniquePerLocHistGlobHist(a: [?aD] int, aMin: int, aMax: int)

   unique with per-locale histograms 

.. function:: proc uniquePerLocAssocGlobHist(a: [?aD] int, aMin: int, aMax: int)

   use when unique values vary over a wide range and and are sparse
   unique with per-locale assoc domains and arrays
   global unique value histogram 

.. function:: proc uniquePerLocAssocGlobAssoc(a: [?aD] int, aMin: int, aMax: int)

   use when unique value vary over a wide range and and are sparse
   unique with per-locale assoc domains and arrays 

.. function:: proc uniquePerLocAssocParUnsafeGlobAssocParUnsafe(a: [?aD] int, aMin: int, aMax: int)

   use when unique value vary over a wide range and and are sparse
   unique with per-locale assoc domains and arrays 

.. function:: proc uniqueMsg(reqMsg: string, st: borrowed SymTab): string

   unique take a pdarray and returns a pdarray with the unique values 

.. function:: proc value_countsMsg(reqMsg: string, st: borrowed SymTab): string

   value_counts takes a pdarray and returns two pdarrays unique values and counts for each value 

