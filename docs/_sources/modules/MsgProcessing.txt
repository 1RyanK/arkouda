.. default-domain:: chpl

.. module:: MsgProcessing

MsgProcessing
=============
**Usage**

.. code-block:: chapel

   use MsgProcessing;

.. function:: proc createMsg(reqMsg: string, st: borrowed SymTab): string

   
   Parse, execute, and respond to a create message 
   
   :arg reqMsg: request containing (cmd,dtype,size)
   :type reqMsg: string 
   
   :arg st: SymTab to act on
   :type st: borrowed SymTab 
   
   :returns: (string) response message
   

.. function:: proc deleteMsg(reqMsg: string, st: borrowed SymTab): string

   
   Parse, execute, and respond to a delete message 
   
   :arg reqMsg: request containing (cmd,name)
   :type reqMsg: string 
   
   :arg st: SymTab to act on
   :type st: borrowed SymTab 
   
   :returns: (string) response message
   

.. function:: proc infoMsg(reqMsg: string, st: borrowed SymTab): string

   
   Takes the name of data referenced in a msg and searches for the name in the provided sym table.
   Returns a string of info for the sym entry that is mapped to the provided name.
   
   :arg reqMsg: request containing (cmd,name)
   :type reqMsg: string 
   
   :arg st: SymTab to act on
   :type st: borrowed SymTab 
   
   :returns: (string)
    

.. function:: proc dumpMsg(reqMsg: string, st: borrowed SymTab): string

   
   Performs an info and value dump on the message-specified sym entry within the provided sym table.
   
   :arg reqMsg: request containing (cmd,name)
   :type reqMsg: string 
   
   :arg st: SymTab to act on
   :type st: borrowed SymTab  
   
   :returns: (string)
   

.. function:: proc strMsg(reqMsg: string, st: borrowed SymTab): string

   
   Response to __str__ method in python str convert array data to string 
   
   :arg reqMsg: request containing (cmd,name)
   :type reqMsg: string 
   
   :arg st: SymTab to act on
   :type st: borrowed SymTab 
   
   :returns: (string)
   

.. function:: proc reprMsg(reqMsg: string, st: borrowed SymTab): string

   Response to __repr__ method in python.
   Repr convert array data to string 
   
   :arg reqMsg: request containing (cmd,name)
   :type reqMsg: string 
   
   :arg st: SymTab to act on
   :type st: borrowed SymTab 
   
   :returns: (string)
   

.. function:: proc arangeMsg(reqMsg: string, st: borrowed SymTab): string

   
   Creates a sym entry with distributed array adhering to the Msg parameters (start, stop, stride)
   
   :arg reqMsg: request containing (cmd,start,stop,stride)
   :type reqMsg: string 
   
   :arg st: SymTab to act on
   :type st: borrowed SymTab 
   
   :returns: (string)
   

.. function:: proc linspaceMsg(reqMsg: string, st: borrowed SymTab): string

   
   Creates a sym entry with distributed array adhering to the Msg parameters (start, stop, len)
   
   :arg reqMsg: request containing (cmd,start,stop,len)
   :type reqMsg: string 
   
   :arg st: SymTab to act on
   :type st: borrowed SymTab 
   
   :returns: (string)
   

.. function:: proc setMsg(reqMsg: string, st: borrowed SymTab): string

   
   Sets all elements in array to a value (broadcast) 
   
   :arg reqMsg: request containing (cmd,name,dtype,value)
   :type reqMsg: string 
   
   :arg st: SymTab to act on
   :type st: borrowed SymTab 
   
   :returns: (string)
   

.. function:: proc efuncMsg(reqMsg: string, st: borrowed SymTab): string

   These ops are functions which take an array and produce an array.
    
    **Dev Note:** Do scans fit here also? I think so... vector = scanop(vector)
    parse and respond to efunc "elemental function" message
    vector = efunc(vector) 
    
   :arg reqMsg: request containing (cmd,efunc,name)
   :type reqMsg: string 
   
   :arg st: SymTab to act on
   :type st: borrowed SymTab 
   
   :returns: (string)
   

.. function:: proc efunc3vvMsg(reqMsg: string, st: borrowed SymTab): string

   
   These are ternary functions which take three arrays and produce an array.
   vector = efunc(vector, vector, vector)
   
   :arg reqMsg: request containing (cmd,efunc,name1,name2,name3)
   :type reqMsg: string 
   
   :arg st: SymTab to act on
   :type st: borrowed SymTab 
   
   :returns: (string)
   

.. function:: proc efunc3vsMsg(reqMsg: string, st: borrowed SymTab): string

   
   vector = efunc(vector, vector, scalar)
   
   :arg reqMsg: request containing (cmd,efunc,name1,name2,dtype,value)
   :type reqMsg: string 
   
   :arg st: SymTab to act on
   :type st: borrowed SymTab 
   
   :returns: (string)
   

.. function:: proc efunc3svMsg(reqMsg: string, st: borrowed SymTab): string

   
   vector = efunc(vector, scalar, vector)
   
   :arg reqMsg: request containing (cmd,efunc,name1,dtype,value,name2)
   :type reqMsg: string 
   
   :arg st: SymTab to act on
   :type st: borrowed SymTab 
   
   :returns: (string)
   

.. function:: proc efunc3ssMsg(reqMsg: string, st: borrowed SymTab): string

   
   vector = efunc(vector, scalar, scalar)
   
   :arg reqMsg: request containing (cmd,efunc,name1,dtype1,value1,dtype2,value2)
   :type reqMsg: string 
   
   :arg st: SymTab to act on
   :type st: borrowed SymTab 
   
   :returns: (string)
   

.. function:: proc where_helper(cond: [?D] bool, A: [D] ?t, B: [D] t, param kind): [D] t

   The 'where' function takes a boolean array and two other arguments A and B, and 
   returns an array with A where the boolean is true and B where it is false. A and B
   can be vectors or scalars. 
   Dev Note: I would like to be able to write these functions without
   the param kind and just let the compiler choose, but it complains about an
   ambiguous call. 
   
   :arg cond:
   :type cond: [?D] bool
   
   :arg A:
   :type A: [D] ?t
   
   :arg B: 
   :type B: [D] t
   
   :arg kind:
   :type kind: param
   

.. function:: proc where_helper(cond: [?D] bool, A: [D] ?t, b: t, param kind): [D] t

   
   
   :arg cond:
   :type cond: [?D] bool
   
   :arg A:
   :type A: [D] ?t
   
   :arg B: 
   :type B: t
   
   :arg kind:
   :type kind: param
   

.. function:: proc where_helper(cond: [?D] bool, a: ?t, B: [D] t, param kind): [D] t

   
   
   :arg cond:
   :type cond: [?D] bool
   
   :arg a:
   :type a: ?t
   
   :arg B: 
   :type B: [D] t
   
   :arg kind:
   :type kind: param
   

.. function:: proc where_helper(cond: [?D] bool, a: ?t, b: t, param kind): [D] t

   
   
   :arg cond:
   :type cond: [?D] bool
   
   :arg a:
   :type a: ?t
   
   :arg b: 
   :type b: t
   
   :arg kind:
   :type kind: param
   

