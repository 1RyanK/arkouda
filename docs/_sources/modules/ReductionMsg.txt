.. default-domain:: chpl

.. module:: ReductionMsg

ReductionMsg
============
**Usage**

.. code-block:: chapel

   use ReductionMsg;

.. data:: config const reductionDEBUG = false

.. data:: const lBins = 2**25*numLocales

.. function:: proc reductionMsg(reqMsg: string, st: borrowed SymTab): string

   
   these functions take an array and produce a scalar
   parse and respond to reduction message
   scalar = reductionop(vector)
   
   

.. function:: proc countReductionMsg(reqMsg: string, st: borrowed SymTab): string

.. function:: proc segCount(segments: [?D] int, upper: int): [D] int

.. function:: proc countLocalRdxMsg(reqMsg: string, st: borrowed SymTab): string

.. function:: proc perLocCount(segments: [?D] int, size: int): [] int

.. function:: proc segmentedReductionMsg(reqMsg: string, st: borrowed SymTab): string

.. function:: proc segmentedLocalRdxMsg(reqMsg: string, st: borrowed SymTab): string

.. function:: proc segSum(values: [] ?t, segments: [?D] int): [D] t

   Segmented Reductions of the form: seg<Op>(values:[] t, segments: [] int)
   Use <segments> as the boundary indices to divide <values> into chunks, 
   and then reduce over each chunk uisng the operator <Op>. The return array 
   of reduced values is the same size as <segments>.
   

.. function:: proc perLocSum(values: [] ?t, segments: [?D] int): [] t

   Per-Locale Segmented Reductions have the same form as segmented reductions:
   perLoc<Op>(values:[] t, segments: [] int)
   However, in this case <segments> has length <numSegments>*<numLocales> and
   stores the segment boundaries for each locale's chunk of <values>. These
   reductions perform two stages: a local reduction (implemented via a call
   to seg<Op> on the local slice of values) and a global reduction of the 
   local results. The return is the same as seg<Op>: one reduced value per segment.
   

.. function:: proc segSum(values: [] bool, segments: [?D] int): [D] int

.. function:: proc perLocSum(values: [] bool, segments: [?D] int): [] int

.. function:: proc segProduct(keys: [] int, values: [], segments: [?D] int): [D] real

.. function:: proc perLocProduct(keys: [] int, values: [] ?t, segments: [?D] int): [] real

.. function:: proc segMean(values: [] ?t, segments: [?D] int): [D] real

.. function:: proc perLocMean(values: [] ?t, segments: [?D] int): [] real

.. function:: proc segMin(keys: [] int, values: [] ?t, segments: [?D] int): [D] t

.. function:: proc perLocMin(keys: [] int, values: [] ?t, segments: [?D] int): [] t

.. function:: proc segMax(keys: [] int, values: [] ?t, segments: [?D] int): [D] t

.. function:: proc perLocMax(keys: [] int, values: [] ?t, segments: [?D] int): [] t

.. function:: proc segArgmin(keys: [] int, values: [] ?t, segments: [?D] int): (AppendExpr.01, AppendExpr.01)

.. function:: proc perLocArgmin(keys: [] int, values: [] ?t, segments: [?D] int): [] int

.. function:: proc segArgmax(keys: [] int, values: [] ?t, segments: [?D] int): (AppendExpr.01, AppendExpr.01)

.. function:: proc perLocArgmax(keys: [] int, values: [] ?t, segments: [?D] int): [] int

.. function:: proc segAny(values: [] bool, segments: [?D] int): [D] bool

.. function:: proc perLocAny(values: [] bool, segments: [?D] int): [] bool

.. function:: proc segAll(values: [] bool, segments: [?D] int): [D] bool

.. function:: proc perLocAll(values: [] bool, segments: [?D] int): [] bool

.. function:: proc segNumUnique(values: [?vD] int, segments: [?sD] int): [sD] int

.. function:: proc perLocNumUnique(values: [] int, segments: [?D] int): [] int

   } 

.. function:: proc perLocNumUniqueHist(values: [] int, segments: [?D] int, minVal: int, valRange: int, numKeys: int): [] int

   } 

.. function:: proc perLocNumUniqueAssoc(values: [] int, segments: [?D] int, numKeys: int): [] int

